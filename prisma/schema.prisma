datasource db {
  provider = "postgresql"
  url = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

generator client {
  provider = "prisma-client-js"
}

enum CaseStatus {
  ONGOING
  CONCLUDED
}

model Case {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  companyId String? @db.Uuid

  code String @unique
  name String
  status CaseStatus @default(ONGOING)

  company Company? @relation(fields: [companyId], references: [id])
  documents Document[]
}

enum ChunkStatus {
  PENDING
  ONGOING
  SUCCESS
  FAILURE
}

model Chunk {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime  @default(now())
  updated DateTime  @default(now())

  countyId String @db.Uuid
  scanId String @db.Uuid

  status ChunkStatus @default(PENDING)
  startDate  DateTime? @db.Date
  page Int
  stubCount  Int?
  hitCount String?

  county County @relation(fields: [countyId], references: [id])
  scan Scan @relation(fields: [scanId], references: [id])
  stubs Stub[]
  ticks Tick[]

  @@index([scanId, created(sort: Asc), status])
}

model Company {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  code String @unique
  name String
  slug String @unique
  cases Case[]

  documents Document[]
}

model County {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())
  ticked DateTime?

  code String @unique
  name String
  slug String @unique

  documents Document[]
  municipalities Municipality[]
  scans Scan[]
  chunks Chunk[]
  stubs Stub[]
}

model Document {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  caseId String @db.Uuid
  companyId String? @db.Uuid
  countyId String @db.Uuid
  municipalityId  String @db.Uuid
  typeId String @db.Uuid
  workplaceId String? @db.Uuid

  code String @unique
  date DateTime @db.Date
  direction String
  typeText String

  case Case @relation(fields: [caseId], references: [id])
  company Company? @relation(fields: [companyId], references: [id])
  county County @relation(fields: [countyId], references: [id])
  municipality Municipality @relation(fields: [municipalityId], references: [id])
  type Type @relation(fields: [typeId], references: [id])
  workplace Workplace? @relation(fields: [workplaceId], references: [id])

  stubs Stub[]
}

model Municipality {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  countyId  String @db.Uuid

  code String @unique
  name String
  slug String @unique

  county County @relation(fields: [countyId], references: [id])
  documents Document[]
}

enum ScanStatus {
  PENDING
  ONGOING
  SUCCESS
  FAILURE
}

model Scan {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime  @default(now())
  updated DateTime  @default(now())

  countyId String @db.Uuid

  status ScanStatus @default(PENDING)
  startDate  DateTime? @db.Date
  chunkCount Int

  chunks Chunk[]
  county County @relation(fields: [countyId], references: [id])
  stubs Stub[]
  ticks Tick[]

  @@index([countyId, created(sort: Asc), status])
}

model Session {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  userId String @db.Uuid

  secret String

  user User @relation(fields: [userId], references: [id])
}

enum StubStatus {
  PENDING
  SUCCESS
  FAILURE
}

model Stub {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  chunkId String @db.Uuid
  countyId String @db.Uuid
  scanId String @db.Uuid
  documentId String? @db.Uuid

  status StubStatus @default(PENDING)
  index Int
  caseName String
  companyName  String
  documentCode  String
  documentType  String
  documentDate DateTime @db.Date

  chunk Chunk @relation(fields: [chunkId], references: [id])
  county County @relation(fields: [countyId], references: [id])
  scan Scan @relation(fields: [scanId], references: [id])
  document Document? @relation(fields: [documentId], references: [id])
  ticks Tick[]

  @@index([created(sort: Asc), status])
}

enum TickType {
  SCAN
  CHUNK
  STUB
}

model Tick {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  type TickType
  scanId String @db.Uuid
  chunkId String? @db.Uuid
  stubId String? @db.Uuid

  scan Scan @relation(fields: [scanId], references: [id])
  chunk Chunk? @relation(fields: [chunkId], references: [id])
  stub Stub? @relation(fields: [stubId], references: [id])
}

model Type {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  name String
  slug String @unique

  documents Document[]
}

model User {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  name String
  email String @unique
  password String

  sessions Session[]
}

model Workplace {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created DateTime @default(now())
  updated DateTime @default(now())

  name String
  code String @unique

  documents Document[]
}
